# リファクタリング計画

## 目的

このリファクタリング計画は、現在のプロジェクトの保守性を向上させることを主な目的としています。現状のコードベースを分析した結果、いくつかの改善すべき点が特定されました。このドキュメントでは、それらの問題点と提案される解決策を詳細に説明します。

## 現状の問題点

### 1. コードの重複

- `src/core/common.ts` と `src/browser/common.browser.ts` が本質的に同じコードを含んでいます。
- 唯一の違いは、一方がESモジュールとして `export` キーワードを使用し、もう一方がグローバル変数として関数を公開している点です。
- このような重複は、機能変更時に両方のファイルを修正する必要があり、メンテナンスコストが高くなります。

### 2. 型定義の問題

- `src/types/types.d.ts` では、`any` 型が多用されています。
- `CaseData` インターフェースが複数の場所で定義されています（common.ts, common.browser.ts, main.ts）。
- 型の一貫性が保たれていないため、コードの保守性と信頼性が低下します。

### 3. ファイル構造と責任分離

- ビジネスロジック、UI処理、データモデルの境界が明確ではありません。
- `main.ts` ファイルが多くの責任を持っており、ファイルサイズが大きくなっています。

### 4. テストの網羅性と構造

- テストが一つのファイル（`test/unit/test.ts`）に集中しています。
- 単体テストと統合テストの明確な分離がありません。

### 5. 環境依存の二重実装

- Node.js環境とブラウザ環境で異なる実装が必要になっており、開発効率が低下しています。
- モダンなビルドツールを活用できていません。

## 改善提案

### 1. コードの共通化と環境依存部分の分離

```
src/
  core/
    common/
      types.ts         # 共通型定義
      constants.ts     # 定数（targetProcedures など）
      parsers.ts       # ファイル解析関連の機能
      evaluator.ts     # 評価ロジック関連の機能
      utils.ts         # ユーティリティ関数
    adapters/
      node.ts          # Node.js 環境固有の実装
      browser.ts       # ブラウザ環境固有の実装
  ui/
    main.ts            # UI関連の処理（小さなコンポーネントに分割）
    components/        # UI処理を小さなコンポーネントに分割
      file-input.ts    # ファイル入力関連のUI処理
      progress.ts      # 進捗表示関連のUI処理
      results.ts       # 結果表示関連のUI処理
```

### 2. ビルドツールの活用

- Webpackを導入し、環境依存のコードをビルド時に適切に処理します。
- これにより、開発者は単一のコードベースで作業でき、ブラウザとNode.js環境の違いを意識する必要がなくなります。
- エントリーポイントを分けることで、ブラウザ用とテスト用のバンドルを別々に生成できます。

### 3. 型定義の一元化と強化

- `src/core/common/types.ts` に全ての型定義を集約します。
- `any` 型の使用を削減し、より具体的な型を定義します。
- 型を使用したコード補完や静的解析の恩恵を最大限に受けられるようにします。

### 4. テスト構造の改善

- ユニットテストとインテグレーションテストを明確に分離します。
- 各モジュールに対応するテストファイルを作成し、テストの管理を容易にします。
- テストカバレッジツールを導入して、テストの網羅性を測定します。

```
test/
  unit/               # 単体テスト
    parsers.test.ts
    evaluator.test.ts
    utils.test.ts
  integration/        # 統合テスト
    workflow.test.ts  # エンドツーエンドのワークフローテスト
  fixtures/           # テストデータ
```

### 5. ドキュメンテーションの強化

- JSDocスタイルのコメントを充実させ、各関数の入出力や目的を明確にします。
- プロジェクト全体のアーキテクチャドキュメントを作成し、新たに参加する開発者が容易に理解できるようにします。

### 6. モダンなデザインパターンの導入

- 依存性注入パターンを導入して、コンポーネント間の結合度を下げます。
- ファクトリーパターンを使用して、環境に応じた適切なオブジェクトを生成します。

## 実装計画

### フェーズ1: 準備とインフラ整備

1. Webpackなどのビルドツールを導入
2. ESLintとPrettierの設定を調整し、コードスタイルを統一
3. 型定義ファイルの再構築

### フェーズ2: コア機能のリファクタリング

1. `common.ts` と `common.browser.ts` の共通コードを抽出し、モジュール化
2. 環境依存の部分をアダプターパターンで分離
3. ユーティリティ関数とビジネスロジックの明確な分離

### フェーズ3: UI処理のリファクタリング

1. `main.ts` の責任を分割し、小さなモジュールに再構成
2. UIコンポーネントの独立性を高め、テスト容易性を向上
3. イベントハンドリングとビジネスロジックの分離

### フェーズ4: テスト強化

1. 各モジュールに対応するユニットテストの作成
2. カバレッジレポートの設定
3. 統合テストの強化

### フェーズ5: ドキュメンテーションと最終調整

1. JSDocコメントの充実
2. プロジェクト構造とアーキテクチャのドキュメント作成
3. パフォーマンス最適化と最終調整

## 期待される効果

1. **保守性の向上**: コードの重複を削減し、変更が必要な箇所を最小限に抑えます。
2. **開発効率の向上**: 環境依存のコードを自動的に処理することで、開発者は本質的なビジネスロジックに集中できます。
3. **バグの減少**: 強力な型チェックとテストカバレッジの向上により、潜在的なバグを早期に発見できます。
4. **拡張性の向上**: 明確な責任分担とモジュール化により、新機能の追加が容易になります。
5. **オンボーディングの容易さ**: 良いドキュメンテーションと明確なコード構造により、新しい開発者が素早くプロジェクトを理解できます。

## 次のステップ

このリファクタリング計画が承認されれば、フェーズ1から順に実装を進めていきます。各フェーズの完了後には、機能が正しく動作することを確認するための包括的なテストを実施します。また、定期的に進捗状況を報告し、必要に応じて計画を調整します。 